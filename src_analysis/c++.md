多态性与将实现多态的函数的访问限定符没有任何关系，private 函数仍然可以实现多态，它的指针仍然位于vtbl中，只不过该函数的多态一般只能在基类的内部由其他非虚函数调用该函数的时候反映出来，访问限定符仅仅限制外部对类的成员的访问权限，它并没有破坏以下规则： 

       通过基类指针或引用调用成员函数时，如果该函数时非虚的，那么将采用静态绑定，即编译时绑定；如果该函数是虚拟的，则采用动态绑定，即运行时绑定。

二．virtual与访问限定符结合

上面我们通过分析，已经知道了多态的实现与访问限定符没有任何关系，访问限定符只是控制类的成员对外部的可见性，但不限制多态。正如上面提到的，将classID声明为virtual private和声明为 virtual public 后再次运行程序，得到的结果是一样的，上面我们简单的地分析了一下表面现象，但这个问题决不是这么简单，让我们挖掘更深层次的意义，我想这应该属于OOA、OOD的范畴了。好，让我们一步步看过来。
## virtual与访问限定符结合

在C++中，虚函数和访问限定符（private、protected、public）可以一起使用来实现一些特殊的设计模式，例如模板方法模式，非虚拟接口（NVI）等。了解虚函数与访问限定符结合的原理，首先需要理解C++中的虚函数和访问限定符。

- **虚函数（Virtual Function）**：在C++中，虚函数主要用于实现多态。基类中定义的虚函数，可以在派生类中被重写（或称为覆盖），并且基类的指针或引用可以调用到派生类中重写的函数。这个特性允许我们以一种通用的方式处理不同类型的对象。

- **访问限定符（Access Specifier）**：在C++中，访问限定符用于定义类成员的访问权限。共有三种访问限定符：private，protected，public。在类的外部，只有公有成员可以被访问。在派生类中，只有公有成员和保护成员可以被访问。私有成员只能在类的内部被访问。

当虚函数和访问限定符结合使用时，可以实现一些强大的设计模式。以下是一个例子，它展示了如何结合使用虚函数和访问限定符来实现模板方法模式：

```cpp
class AbstractClass {
public:
    // 这是一个公有接口，它定义了一种算法的框架
    void TemplateMethod() {
        // 一些公共操作...
        PrimitiveOperation1();
        // 一些公共操作...
        PrimitiveOperation2();
        // 一些公共操作...
    }

private:
    // 这些是私有的虚函数，它们可以在派生类中被重写
    virtual void PrimitiveOperation1() = 0;
    virtual void PrimitiveOperation2() = 0;
};

class ConcreteClass : public AbstractClass {
private:
    // 在派生类中重写虚函数
    void PrimitiveOperation1() override {
        // 具体操作1的实现
    }

    void PrimitiveOperation2() override {
        // 具体操作2的实现
    }
};
```

在这个例子中，`AbstractClass`是一个基类，它提供了一个公有接口`TemplateMethod()`，这个接口调用了两个私有的虚函数`PrimitiveOperation1()`和`PrimitiveOperation2()`。这两个虚函数在基类中没有具体的实现，必须在派生类中被重写。这样，当基类的公有接口被调用时，虚函数的调用实际上会调用到派生类中重写的函数。这就是虚函数与访问限定符结合的原理。


在C++中，当我们在一个派生类中覆盖基类中的虚函数时，实际上是在虚函数表（vtable）中将基类的函数实现替换为派生类的函数实现。这是通过修改vtable中相应函数的指针来完成的。

让我们更深入地探讨一下这个过程。

首先，假设我们有一个基类Base，它包含两个虚函数，vfunc1和vfunc2：

```cpp
class Base {
public:
    virtual void vfunc1() { /* some implementation */ }
    virtual void vfunc2() { /* some implementation */ }
};
```

编译器为Base类生成一个vtable，其中包含两个函数指针，分别指向vfunc1和vfunc2的实现：

```
Base's vtable:
+------------+
| vfunc1 ptr |
+------------+
| vfunc2 ptr |
+------------+
```

现在，假设我们有一个派生类Derived，它覆盖了基类中的vfunc1：

```cpp
class Derived : public Base {
public:
    void vfunc1() override { /* some other implementation */ }
};
```

编译器为Derived类生成一个新的vtable。新的vtable是基类vtable的一个复制，但是vfunc1的指针被更新为指向Derived::vfunc1的实现：

```
Derived's vtable:
+------------+
| vfunc1 ptr |  --> points to Derived::vfunc1
+------------+
| vfunc2 ptr |  --> still points to Base::vfunc2
+------------+
```

这就是C++虚函数的覆盖规则。简单来说，当一个派生类覆盖基类的虚函数时，vtable中的函数指针会被更新为指向派生类的函数实现。

这也是C++实现多态的机制。当我们通过基类的指针或引用调用虚函数时，实际执行的是vtable中相应函数的实现。如果这个指针或引用实际上指向一个派生类的对象，那么就会调用派生类的实现。



当我们将classID声明为非虚的 private时，子类将看不见它，当然也就无法覆盖或重载它，即在这中情况下，子类无法更改classID的实现，但是子类继承了公共接口work（），而这个接口调用了classID，所以，可以看作，子类间接地继承了classID的实现，并且这个实现是无法修改的。于是，我可以说，基类中声明一个普通私有成员函数，表示这是一个不可被更改的实现细节。

再来讨论将classID声明为virtual private的情况，声明为private表示基类不想让子类看到这个函数，但是又声明为virtual，表示基类想让这个函数实现多态。呵呵，基类既想实现多态，却又不让子类看见这个函数，这似乎有点自相矛盾，是吗？其实，这其中的意思是，子类既可以修改这个实现，也可以继承其基类默认的实现。所以可以这么说，如果基类中有一个虚拟私有成员函数，表示这是一个“可以”被派生类修改的实现细节。注意，当中的用词，是“可以”，而不是别的。

最后来看看将classID声明为virtual protected的情况。将classID声明为protected表示基类“需要”子类看见这个函数，注意，我使用“需要”这个动词，这个词表示了一定的“强制”意味。与将classID声明为virtual private的情况对比一下，我想你已经知道答案了，即是，如果基类中有一个虚拟保护成员函数，表示这是一个必须被派生类修改的实现细节。“必须”这个词表达了强制的意思。

关于“将virtual与访问限定符结合”的问题就讨论这么多，你也许说，还漏掉了将classID声明为virtual public的情况。是的，其实，我并不推荐将虚拟函数声明为public，尽管这种方式在现在很流行，我推荐将其使用virtual protected来替换，这就说明基类必须另外发布一个几乎不更改的非虚public接口，在这个接口中调用了virtual protected或virtual private函数，这样以来，我们就对类的内部实现作了进一步的隐藏，而这无论是对系统的可扩展性，还是可维护性都是大有帮助的。“虚拟函数应该和数据成员一样对待――让他们成为私有的，除非设计需求表明应该有较少的限制。提升它们到更高存取级别比把它们降到更私有的级别更容易些。”

最后，把上面所说的小结一下：

      基类中的一个普通私有成员函数，表示这是一个不可被更改的实现细节。 
      基类中的一个虚拟私有成员函数，表示这是一个可以被派生类修改的实现细节。
      基类中的一个虚拟保护成员函数，表示这是一个必须被派生类修改的实现细节。 
      最好不要将虚拟成员函数声明为public，而是用protected来替换。

三．模板方法模式

在理解了上面所述的内容的情况下，再来理解模板方法模式就非常easy了，模板方法是在GOF的经典大作《设计模式》中阐述了一种模式，该模式定义了一个操作中的算法的骨架，而将一些步骤的实现延迟到子类中，模板方法使得派生类可以不改变一个算法的结构即可重定义算法的某些特定步骤。在这里，我不想再重复解释这个模式如何实现的，我仅仅举个例子，这个例子将体现出模板方法中最重要的思想。

假设基类定义的一个算法的骨架由3个步骤完成，其中第一个步骤是该继承体系中不可被改变的一个步骤，即所有的类对该步骤的实现都是一样的，那个这个步骤可以设置为非虚的private ；第二个步骤是一个可以被派生类改写也可以不被改写的步骤，通过上面的讨论知道，可以将其设为virtual private ；第三个步骤是针对每一个派生类的实现都不同，那么这个步骤可以被设为virtual protected ，而且，步骤三只能针对特定的派生类才有意义，