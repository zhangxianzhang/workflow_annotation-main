#! https://zhuanlan.zhihu.com/p/416556786
# workflow 源码解析 09 : Executor 

项目源码 : https://github.com/sogou/workflow

更加详细的源码注释可看 : https://github.com/chanchann/workflow_annotation



## `__CommManager` 类

在网络服务器库架构中，`__CommManager` 类的作用可能是提供一个全局的通信管理器，用于集中管理与通信相关的组件和资源。它可能承担以下功能和作用：

1. **提供全局访问点**：作为单例模式的管理器，它可以提供全局唯一的访问点，使得不同模块或组件可以方便地访问通信相关的功能和资源。

2. **调度器管理**：通过 `scheduler_` 对象提供调度器的管理和操作，负责处理任务的调度和执行。其他模块可以通过 `get_scheduler()` 函数获取调度器对象，以便添加、删除和执行任务。

3. **路由管理**：通过 `route_manager_` 对象提供路由管理的功能，用于管理和配置网络请求的路由规则，以便将请求分发到不同的处理程序。

4. **IO服务管理**：通过 `io_server_` 对象提供IO服务的管理和操作，用于处理网络IO操作，如接受连接、读写数据等。`get_io_service()` 函数用于获取IO服务的实例，并确保只有一个实例被创建和初始化。这可以提供高效的异步IO支持，并避免在多个模块之间重复创建和初始化IO服务。

5. **DNS服务管理**：通过 `dns_manager_` 对象提供DNS服务的管理和操作，用于解析域名和获取IP地址。`get_dns_manager_safe()` 函数确保只有一个实例被创建和初始化，提供线程安全的访问。

6. **全局设置获取**：通过 `__WFGlobal::get_instance()` 获取全局设置的实例，并使用其中的参数进行初始化和配置，以便根据设置调整调度器和其他组件的行为。

总的来说，`__CommManager` 在网络服务器库架构中起到集中管理和协调不同组件的作用，提供全局访问和资源管理，以支持高效的网络通信和请求处理。它整合了调度器、路由管理、IO服务和DNS服务等核心功能，提供统一的接口和配置，简化了网络服务器的开发和管理。

### 饿汉模式
根据给出的代码，`__CommManager` 类中采用的是饿汉式单例模式。

在C++的饿汉式单例模式中，实例对象在程序开始执行时就会被创建，而不是在第一次使用时才创建。具体来说，饿汉式单例模式使用了静态成员变量来存储单例实例，静态成员变量在程序运行时会被初始化，因此实例对象会在程序开始时被创建。
这意味着，在程序启动时，单例类的实例对象就会被创建，并且在整个程序的生命周期中，只会存在一个实例对象。该实例对象可以在任何需要的地方被访问和使用。
在 `__CommManager` 类中，静态成员函数 `get_instance()` 并没有通过懒加载的方式创建实例，而是直接返回一个静态的 `__CommManager` 对象。

选择饿汉式单例模式可能是出于以下考虑：

1. **线程安全**：饿汉式单例模式在类加载时就创建实例，保证了多线程环境下的线程安全性，无需额外的线程同步措施。

2. **简单易用**：饿汉式单例模式实现起来相对简单，代码量较少，易于理解和维护。

3. **性能优化**：通过在类加载时创建实例，避免了在多个地方重复创建实例的开销，可以提高程序的性能。

需要注意的是，饿汉式单例模式在类加载时就创建实例，可能会造成资源的浪费，特别是在实例对象较大或需要耗费较多资源时。因此，如果实例对象的创建和初始化较为复杂，或者希望实现延迟加载，可以考虑使用懒汉式单例模式。但在 `__CommManager` 类中，并没有体现这种需求，因此选择了饿汉式单例模式。


非常抱歉之前的回答有误。根据提供的代码，可以看到 `get_instance()` 函数实际上是通过懒加载方式创建实例的。

在上述代码中，`get_instance()` 函数返回的是一个指向静态 `__CommManager` 对象的指针。静态局部变量 `kInstance` 在第一次调用 `get_instance()` 函数时被初始化，并且该静态变量会一直存在于函数的整个生命周期中。

通过使用静态局部变量的方式，实现了懒加载的效果。也就是说，实例对象只有在第一次调用 `get_instance()` 函数时才会被创建。之后的调用都会返回同一个实例对象。

这种实现方式也被称为懒汉式单例模式，因为实例对象在第一次使用时才会被创建。

需要注意的是，这种懒加载的方式在多线程环境下可能会存在竞态条件（race condition）的问题。如果多个线程同时调用 `get_instance()` 函数并且实例尚未创建时，可能会导致多个实例对象被创建。为了确保线程安全，可以采用线程同步机制，例如使用互斥锁（mutex）或双重检查锁定（double-checked locking）来解决竞态条件的问题。

### 静态的 __CommManager 对象什么时会被初始化？是在第一次使用“static __CommManager *get_instance()”时吗？

根据 C++ 的静态初始化规则，静态成员变量会在程序启动时（在 `main()` 函数执行之前）进行初始化。对于静态对象，在程序加载和初始化时就会创建和初始化，而不是在第一次访问静态成员函数时才创建。

实际上，在饿汉式单例模式中，静态的 `__CommManager` 对象 `kInstance` 是在程序运行时被初始化的，而不是在第一次调用 `get_instance()` 函数时。


- 在饿汉式单例模式中，静态的 `__CommManager` 对象 `kInstance` 是在程序加载时（在 `main()` 函数执行之前）被初始化的。
- 当程序加载时，`__CommManager` 类被加载到内存中，静态成员变量 `kInstance` 的内存空间也被分配。
- `kInstance` 对象会在程序运行之前创建，并通过调用 `__CommManager` 的默认构造函数进行初始化。
- 之后，无论是否调用 `get_instance()` 函数，`kInstance` 都已经存在于内存中，它的初始化发生在程序加载阶段，并不依赖于函数的调用。

因此，在饿汉式单例模式中，静态的 `__CommManager` 对象在程序运行之前就已经被初始化，而不是在第一次使用 `get_instance()` 函数时。

对于静态成员变量，它们的初始化时间点是在程序开始执行之前，即在进入 `main()` 函数之前进行初始化。在静态成员函数 `get_instance()` 中返回静态的 `__CommManager` 对象时，并不会触发该对象的初始化。

静态成员变量会在编译时被初始化，而不是在运行时。在饿汉式单例模式中，静态成员变量会在程序启动时被初始化为一个唯一的实例对象。因此，在第一次使用 `static __CommManager *get_instance()` 方法时，并不会触发 `__CommManager` 对象的初始化，因为它已经在程序启动时被初始化为一个静态对象。

简而言之，静态的 `__CommManager` 对象会在程序启动时进行初始化，而不是在第一次使用 `get_instance()` 方法时。在使用 `get_instance()` 方法时，只是返回之前已经初始化的静态对象的指针，而不会触发对象的重新初始化。这确保了在整个程序执行过程中都使用同一个全局唯一的 `__CommManager` 对象。

当程序启动时，静态的 `__CommManager` 对象会在编译时进行初始化。以下是一个示例，用于详细解释静态对象的初始化时机：

```cpp
#include <iostream>

class __CommManager {
public:
    __CommManager() {
        std::cout << "Initializing __CommManager" << std::endl;
    }
};

static __CommManager instance;  // 静态的 __CommManager 对象，在程序启动时进行初始化

int main() {
    std::cout << "Inside main()" << std::endl;
    return 0;
}
```

在上述示例中，静态的 `__CommManager` 对象 `instance` 在程序启动时进行初始化。当程序运行时，首先会调用 `__CommManager` 的构造函数，输出 `"Initializing __CommManager"`。然后，程序继续执行 `main()` 函数中的代码。

无论 `__CommManager` 对象是否在 `main()` 函数中使用，它的初始化都会在程序启动时发生。即使在 `main()` 函数中没有直接访问或使用 `__CommManager` 对象，该对象的构造函数仍会在程序启动时执行。

执行上述示例代码，输出将是：

```
Initializing __CommManager
Inside main()
```

这表明 `__CommManager` 对象的初始化发生在程序启动时，并不是在第一次使用 `get_instance()` 方法时触发。在 `get_instance()` 方法中，只是返回已经初始化的静态对象的指针，而不会再次触发对象的初始化。

### 静态局部变量 和 静态类成员函数会被保存在哪里
静态局部变量和静态类成员函数在内存中的存储位置不同。

1. 静态局部变量：
   - 静态局部变量是在函数内部定义的变量，但其生命周期与程序的运行周期相同。
   - 静态局部变量存储在静态数据区，也称为全局数据区或BSS段。
   - 在程序加载时，静态局部变量的内存空间就被分配，并且被初始化为默认值（对于基本类型是0或空指针，对于自定义类型是调用默认构造函数）。
   - 静态局部变量只会被初始化一次，在程序的执行过程中保持其值不变。

2. 静态类成员函数：
   - 静态类成员函数是属于类而不是对象的函数，它可以通过类名直接访问，无需创建类的实例。
   - 静态类成员函数的存储位置与其他静态成员变量相同，它们都存储在静态数据区。
   - 静态类成员函数不依赖于特定对象的状态，因此它们不访问对象的成员变量。
   - 静态类成员函数在程序加载时已经存在，并且可以通过类名直接调用，无需创建类的实例。

总结：
- 静态局部变量存储在静态数据区，它们在程序加载时被分配内存空间，并在程序的整个运行周期内保持其值不变。
- 静态类成员函数也存储在静态数据区，它们不依赖于对象的状态，可以通过类名直接访问和调用。它们在程序加载时已经存在，并且可以在任何时候调用，无需创建类的实例。

## 初始化调度器（scheduler_）是初始化线程池吗？
是的，初始化调度器 `scheduler_` 可能涉及初始化线程池。在网络服务器库架构中，调度器通常使用线程池来管理并发任务的执行。线程池是一组预先创建的线程，可用于处理并发请求和连接。通过线程池，服务器能够同时处理多个请求，并充分利用系统资源，提高性能和并发能力。

在 `__CommManager` 的构造函数中，调度器（`scheduler_`）通过调用 `scheduler_.init(settings->poller_threads, settings->handler_threads)` 进行初始化。其中，`settings->poller_threads` 表示轮询线程数，`settings->handler_threads` 表示处理线程数。这些参数可能由全局设置或配置文件指定。

在初始化过程中，调度器可能会创建指定数量的线程，并将它们添加到线程池中。这些线程会在后续的运行中被调度器使用，用于执行并发任务，例如处理请求、接收数据、发送数据等。通过线程池的管理，服务器能够充分利用系统资源，同时控制线程的数量和并发度，以实现高效的并发处理能力。

## 同步操作
在编程中，同步操作指的是按照顺序执行的操作，每个操作必须在前一个操作完成之后才能开始。在多线程或并发环境中，同步操作可以用于保证多个线程或进程之间的数据一致性和正确性。

举个例子，假设有一个银行账户对象，多个线程可以同时访问该账户进行存款和取款操作。在这种情况下，如果两个线程同时进行取款操作，可能会导致数据不一致的问题。为了解决这个问题，可以使用同步操作来确保一次只有一个线程可以对账户进行操作。

下面是一个使用同步操作的示例：

```cpp
#include <iostream>
#include <mutex>

class BankAccount {
private:
    double balance;
    std::mutex mtx; // 互斥锁

public:
    BankAccount(double initialBalance) : balance(initialBalance) {}

    void withdraw(double amount) {
        std::lock_guard<std::mutex> lock(mtx); // 对账户加锁，保证同一时刻只有一个线程可以执行操作
        if (balance >= amount) {
            balance -= amount;
            std::cout << "Withdrawal of " << amount << " successful. New balance: " << balance << std::endl;
        } else {
            std::cout << "Insufficient funds." << std::endl;
        }
    }

    void deposit(double amount) {
        std::lock_guard<std::mutex> lock(mtx); // 对账户加锁，保证同一时刻只有一个线程可以执行操作
        balance += amount;
        std::cout << "Deposit of " << amount << " successful. New balance: " << balance << std::endl;
    }
};

int main() {
    BankAccount account(1000.0);

    // 创建多个线程进行取款和存款操作
    std::thread t1([&]() {
        account.withdraw(500.0);
    });

    std::thread t2([&]() {
        account.withdraw(800.0);
    });

    std::thread t3([&]() {
        account.deposit(200.0);
    });

    t1.join();
    t2.join();
    t3.join();

    return 0;
}
```

在上述示例中，使用了互斥锁 `std::mutex` 来保护账户的 `withdraw()` 和 `deposit()` 方法，确保在同一时刻只能有一个线程访问账户并执行操作，从而避免了数据不一致的问题。 `sync_operation_begin()` 和 `sync_operation_end()` 函数可以用于计数同步操作的开始和结束，以便在同步操作执行期间适当地增加或减少处理线程的数量，以优化性能和资源的利用。

## poller_threads`和`handler_threads`
`poller_threads`和`handler_threads`是`WFGlobalSettings`结构体的成员，分别用于设定poller线程和处理器线程的数量。

- `poller_threads`: 这个值设定了poller线程的数量。Poller线程用于处理IO事件，例如，等待网络套接字就绪，读写数据等。当poller线程数被设定为4，就表示系统将会创建4个线程用来处理这些IO事件。选择的线程数会影响到系统处理IO事件的能力，线程数过少可能会导致处理能力不足，而线程数过多又可能引起上下文切换过多、线程竞争等问题，需要根据实际的系统负载情况进行选择。

- `handler_threads`: 这个值设定了处理器线程的数量。处理器线程用于执行任务的处理逻辑，例如计算、业务逻辑处理等。这个值设定为20就表示会创建20个线程来处理这些任务。同样的，处理器线程的数量需要根据实际情况进行选择，需要考虑的因素包括CPU的核心数量、任务的复杂度、等待IO的时间等。

总的来说，这两个参数都是与并发处理能力密切相关的参数。根据实际的系统情况、任务特性等来调整这两个参数，可以使系统达到最佳的性能。

### 举例解释poller_threads和handler_threads的运用
首先，我们先理解`poller_threads`和`handler_threads`的定义：

- `poller_threads` 是用于监听和处理IO事件的线程数。比如，一个服务器程序需要接受和处理客户端的连接请求，那么这个过程就可以被 `poller_threads`来处理。

- `handler_threads` 是用于执行具体的业务逻辑处理的线程数。比如，一个服务器程序在接受到客户端的请求后，需要进行一些计算或者查询数据库等操作，那么这些操作就可以交给 `handler_threads` 来处理。

假设我们现在要设计一个基于HTTP的服务器程序，这个服务器程序的功能是接收HTTP请求，查询数据库，然后返回数据。那么 `poller_threads` 和 `handler_threads` 的应用就会是这样：

1. 客户端发送HTTP请求到服务器。

2. `poller_threads` 接收到这个HTTP请求，然后将这个请求的处理交给 `handler_threads`。

3. `handler_threads` 接收到这个HTTP请求后，进行数据库查询操作，然后生成HTTP响应。

4. `handler_threads` 将生成的HTTP响应返回给 `poller_threads`。

5. `poller_threads` 将HTTP响应发送回给客户端。

通过这个例子，我们可以看出 `poller_threads` 主要是用来处理网络IO相关的操作，而 `handler_threads` 主要是用来处理具体的业务逻辑。他们的合理配置和使用，可以使得服务器程序更好地处理并发请求，提高服务器的处理效率。