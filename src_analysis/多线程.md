## 线程模型 
在Linux系统中，C语言的线程库（如POSIX线程库pthread）实际上创建的是轻量级进程（lightweight process），也被称为内核线程。这些线程在用户空间被视为线程，但在内核中，它们被视为进程。它们有自己的PID，但在同一进程中的所有线程会共享相同的虚拟内存空间，文件描述符，用户ID，组ID等资源。

这种设计模型被称为N:1模型，即用户空间的多个线程被映射到一个内核线程上。这样的好处是线程切换不需要涉及内核，只需要在用户空间进行，所以线程切换的成本更低。

然而，一个问题是如果一个线程阻塞（比如进行I/O操作），那么整个进程都会被阻塞，因为在内核看来，所有的线程就是一个进程。因此，现代的Linux系统中，C语言的线程库通常使用1:1模型，即每一个用户线程都对应一个内核线程。这样，一个线程的阻塞不会影响其他线程。不过，线程切换会涉及到内核，所以成本会略高一些。

总的来说，在Linux系统中，C语言的线程库创建的线程在用户空间被视为线程，在内核空间被视为轻量级的进程或者内核线程。
## 地址空间
在同一进程中的多个线程共享同一地址空间。这意味着在进程的所有线程中，全局变量和堆内存的地址是相同的。这也是线程间通信比进程间通信更容易、效率更高的原因之一。

然而，每个线程有自己独立的栈空间，这意味着栈上的局部变量在每个线程中是不同的，即使它们在内存中的相对地址（相对于栈底）相同。

例如，假设你有一个全局变量和一个函数，该函数创建一个局部变量：

```cpp
#include <iostream>
#include <pthread.h>

int global_var;

void* thread_func(void*) {
    int local_var;
    std::cout << "Global variable: " << &global_var << "\n";
    std::cout << "Local variable: " << &local_var << "\n";
    return nullptr;
}

int main() {
    pthread_t thread1, thread2;
    pthread_create(&thread1, nullptr, thread_func, nullptr);
    pthread_create(&thread2, nullptr, thread_func, nullptr);

    pthread_join(thread1, nullptr);
    pthread_join(thread2, nullptr);

    return 0;
}
```

在这个程序中，`global_var` 在所有线程中的地址将会是相同的，而 `local_var` 在每个线程中的地址将会是不同的。